# JVM 类加载过程



## 代码是如何运行起来的



>  将我们编写的`*.java`的文件打包成`jar包或war包` 然后通过 **tomcat或者Java -jar ** 命令运行



这里面就涉及到编译文件, 打包以后, `jar包与war包中包含的都是class文件`,  我们分别介绍一下jar包的运行 与 war运行的步骤



- jar包
  - 在打包为jar包时需要标识main方法入口全限定名, 在运行时jvm会以main方法为入口开始加载
- war包
  - war 包通过**tomcat**进行加载, **tomcat**中存在<u>Bootstrap</u>类, 以<u>Bootstrap</u>类的main方法为入口开始加载

<img src="https://gitee.com/panda_soft/note_images/raw/master/path/20210421112358.png" style="zoom:50%;" />



### 类加载子系统



**是什么将class文件转化为二进制流将类加载到内存中的?**

> 答 : classloader, 因为classloader 篇幅太长, 我这里在另一篇文章中重点叙述了
>
> ​	  要想将*.class 文件加载进 JVM 需要ClassLoader, 

<img src="https://gitee.com/panda_soft/note_images/raw/master/path/20210421113209.png" style="zoom:40%;" />



### 字节码执行引擎



> JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了
>
> 比如你的代码中有一个“main()”方法，那么JVM就会从这个“main()”方法开始执行里面的代码。
>
> 需要哪个类的时候，就会使用类加载器来加载对应的类，反正对应的类就在“.class”文件中



## 类加载过程



<img src="https://gitee.com/panda_soft/note_images/raw/master/path/20210425184921.png" style="zoom:43%;" />



### 装载



​		**`类的装载是指, 将类的.class文件中的二进制数据读入内存中,将其放在运行时数据区的方法区内, 然后再堆中创建java.lang.class对象`**用来封装方法区的数据结构..

​		类的加载最终产品在位于堆中的class对象, Class对象封装了类在方法区内的数据结构, 并且向 java开发者 提供了访问方法区的接口,

​		

​		**JVM规范允许类加载器在预料某个类将要加载被使用时就会加载`类加载器`,** 如果预加载的过程中遇到.class文件缺失或者错误, 类加载器必须在程序首次主要加载类时才报告错误, 如果这个类一直没有主动使用, 那么就不会报告异常



加载.class的途径:

1. 本地系统直接加载
2. 通过网络.class文件
3. zip.jar等归档文件中加载
4. 从专有数据库中加载
5. 将java源文件动态编译



​		JVM类装载阶段步骤:
- 通过一个类的全限定名称获取类的二进制字节流
- 将字节流代表的静态存储结构转换为方法区的运行时数据结构
  - 静态存储结构:[class文件组成](https://blog.csdn.net/m0_37871594/article/details/116048435)
  - 运行时数据结构: [JVM内存结构](https://blog.csdn.net/m0_37871594/article/details/115917462#comments_16071321)
    - 方法区部分介绍了该内容
- 在堆中生成java.lang.Class对象,作为访问方法区的入口



### 连接

#### 验证



​		验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。

​		不同的虚拟机对类验证的实现可能会有所不同.



​		但大致都会完成以下四个阶段的验证：

- 文件格式的验证
  - 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
- 元数据的验证
  - 对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
- 字节码验证
  - 该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
- 符号引用验证		
  - 这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

​		



#### 准备



准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。 

> 注：
>
> 1. 这时候进行内存分配的**`仅包括类变量（static）`**，而**`不包括实例变量，实例变量会在`**对象实例化时随着对象一块分配在Java堆中。
> 2. 这里所设置的初始值通常情况下是**`数据类型默认的零值（如0、0L、null、false等）`**，而不是被在Java代码中被显式地赋予的值。



#### 解析



**解析阶段是虚拟机将`class文件中的常量池`中符号引用替换为直接引用的过程**

**`符号引用`**（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。

**`直接引用`**（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。



- **`类或接口的解析`**: 判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析
- **`字段解析`**: 对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束
- **`类方法解析`** : 对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口
- **`接口方法解析`**: 与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了



### 初始化



​		类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。

​		到了初始化阶段，才真正开始执行类中定义的Java程序代码。 **`初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化`**

​		①声明类变量时指定初始值

​		②使用静态代码块为类变量指定初始值


