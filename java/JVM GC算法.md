# JVM GC 算法



## 标记清除

标记-清除算法将垃圾回收分为两个阶段, 标记阶段和清除阶段

在标记阶段,首选从根节点GC roots , 标记所有从根节点的对象, 未被标记的对象就是未被引用的垃圾对象,然后, 在清除阶段,清除所有未被标记的对象



**存活对象较多的情况下比较高效**

缺点

​	扫描了整个空间两次,第一次标记存活对象, 第二次 清除没有标记的对象



## 复制算法



从GC roots进行扫描, 标记处所有存活对象, 并将这些存活对象赋值到一块新的内存,之后将原来的一块内存全部回收



![image-20200901144521333](/Users/huxuekuo/Library/Application Support/typora-user-images/image-20200901144521333.png)



**存活对象较少的情况下比较搞笑**

**扫描了整个空间一次**

**适用于新生代: 基本上 98%的对象是朝生夕死的存活下来的会很少**



缺点:

​	需要一块空的内存空间

​	需要复制移动对象



## 标记压缩



标记压缩,是在 标记清除的基础上做了 一些优化, 首先也是需要从根节点开始对所有可达对象做一次标记 , 但以后 它并不简单的清理未标记的对象, 而是将所有存活的对象压缩到内存的另一端, 之后, 清理边界所有的空间, 这种方法避免了碎片产生, 又不需要两块相同的空间,





## 分代算法



其实分代算法就是在JVM中不同阶段使用不同的GC算法, 



## GC roots

GC roots(Garbage Collector) roots, 标记清除算法使用了GC roots进行标记存活节点, 哪什么是GC roots?

1. Class - 由系统类加载器(system class loader ) 加载的对象, 这些类是不能被回收的, 他们可以以静态字段的方式保持持有其他对象, 我们需要注意一点就是, 通过用户自定义的类加载器的类, 除非相应java.lang.class 实例以其他的某种或多种方式成为roots, 否则他们并不是roots
2. thread - 存活的线程
3. Stack local - java方法的local变量或者参数
4. JNI Local - JNI方法的local变量或者参数
5. JNI Global - 全局JNI引用
6. Monitor  Used - 用于同步的监控对象
7. Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。

