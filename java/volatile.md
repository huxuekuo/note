# volatile 



## 问题介绍



​      为了提高处理器的处理效率, 在处理器与内存之间添加了多级缓存, 由于引入了多级缓存就会发生缓存不一致问题, 每个`线程都有自己工作内存`, 自己的工作内存当中保存了自己使用到的变量从主内存复制到自己的工作内存中,



> 注意: 介绍一下`status`修饰静态变量, 当一个变量被`status`修饰,该变量所有实例共享,存在一个误区`在多线程中静态变量的改变其他线程JVM尽量也会保证可见性,但是不能完全保证`



详细status关键字介绍地址 : `未更新...`

## volatile 可见性



> 所有变量都存储在主内存, 但是每个线程有自己的工作内存, 工作内存是不能互相访问的, 线程的工作内存中保存了该线程使用到的变量副本,线程对变量的所有操作都必须在工作内存中, 不能直接操作主内存, 



当volatile修饰的变量在修改后立即更新到主内存中,在每次使用之前都从主内存获取刷新到本地内存,因此可以保证volatile的可见性

## volatile 有序性



指令重排序介绍地址 : `未更新...`



volatile 可以防止指令重排序, 这就保证了代码执行的有序性,



## 注意



- volatile 不能保证原子性



