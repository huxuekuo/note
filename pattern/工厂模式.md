# 工厂模式



## 优点

	1. 只要客户知道要创建对象的标签就可以在工厂中获得具体对象
 	2. 扩展性强,如果有新的实现类加入只需要更改工程对象
 	3. 屏蔽产品具体实现,调用者只需要关系接口,不需要关系实现类内部



## 代码实现



~~~java
public interface Car {
	
	public void getCar();

}
public class SuperCar implements Car {

	public void getCar() {
		System.out.println("跑车");
		
	}
}
public class DefaultCar implements Car{

	@Override
	public void getCar() {
		System.out.println("普通车");
	}

}
public enum CarEmun {

	SUPERCAR, DEFAULTCAR;
}
	public Car getCar(CarEmun carEmun) {
		if (CarEmun.SUPERCAR == carEmun) {
			return new SuperCar();
		} else if (CarEmun.DEFAULTCAR == carEmun) {
			return new DefaultCar();
		} else {
			return null;
		}
	}
}
public class Test {
	
	/**
	 * 缺点:
	 * 		如果在类多的情况下代码量大,
	 * 		工厂内有大量实例,违反高内聚原则
	 * 优点:
	 * 		可以根据外界给定的信息创建类,明确区分了各自的职责
	 * @param args
	 */
	public static void main(String[] args) {
		StaticFactory factory = new StaticFactory();
		Car car = factory.getCar(CarEmun.SUPERCAR);
		car.getCar();
	}
}
~~~

