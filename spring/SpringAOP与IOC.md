# Spring AOP 与 IOC



# IOC (Inversion of control`控制反转`)



> IOC 不是一个技术, 而是一种思想



在传统的Java SE中, 我们使用一个对象时需要明确`new`一个对象, 而引入一个`Spring IOC`后 我们将控制权限教给了`Spring容器`来控制.所有对象创建到销毁由`Spring`来控制,**控制以后怎么来使用呢? 这里引入了一个DI(依赖注入)**来实现



## IOC 扩展 `DI(依赖注入)`



上面我的讲到 Spring 的IOC 将 对象的创建于销毁进行了控制, 只是控制了好像就是一个残次品**就好像, 以前我们自己做饭, 现在有一个饭店将做饭的工作代替了, 我们现在怎么去吃呢? **



对象之间的依赖由容器运行中来决定, 由容器动态决定将依赖关系注入到组件之中,及容器动态的向对象提供他需要的外部资源(`对象`,`常量`...)



**就好像,我们写了一个我们需要的菜品,然后饭店来提供给我们, 提供需要一个`服务员DI就像那个服务员, 给我们上菜`**



# AOP 



AOP 被称为面向切面编程, 看一下下面的Demo



```java
public class UserServiceImpl{
  
  public Result add(){
    // start 开启事务
    addUser();
    // commit 提交事务
  }
  
  public Result update(){
    // start 开启事务
    addUser();
    // commit 提交事务
  }
}
```



这里我们看到 `开启事务与提交事务`代码冗余了, 这个时候我们想到了了可以将**开启事务与提交事务抽取出来变成一个公共的类** 抽取成类的方式我们称之为：**纵向抽取**,但是，我们现在的办法不行：即使抽取成类还是会出现重复的代码，因为这些逻辑(开始、结束、提交事务)**依附在我们业务类的方法逻辑中**！



现在纵向抽取的方式不行了，AOP的理念：就是将**分散在各个业务逻辑代码中相同的代码通过横向切割的方式**抽取到一个独立的模块中！



## AOP 原理



AOP底层默认使用了`JDK动态代理`实现, 如果被代理的目标对象实现了至少一个接口,则会使用`JDK动态代理`,如果该目标没有实现任何接口, 则会创建一个`CGLIB代理`, 如果你希望强制使用`CGLIB代理`, 会出现一个问题**1. 无法通知 被final的方法,因为他们不能被复写**,



### `JDK代理与CGLIB代理`的实现方式



#### JDK

> 是因为代理对象是由JDK动态生成的，而不像静态代理方式写死代理对象和被代理类，不灵活。
>
> JDK动态代理基于拦截器和反射来实现。
>
> JDK代理是不需要第三方库支持的，只需要JDK环境就可以进行代理，使用条件：
>
> 1）必须实现InvocationHandler接口；
>
> 2）使用Proxy.newProxyInstance产生代理对象；
>
> 3）被代理的对象必须要实现接口；



##### 静态代理和动态代理

- 静态代理**由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 **
- 动态代理**动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 **

#### CGLIB

> CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑
>
> CGLIB 是继承了被代理的类,
>
> Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低
>
> Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高



